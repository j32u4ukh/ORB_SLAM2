# 編譯期
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j4

# 執行期
$ /home/j32u4ukh/Documents/ORB_SLAM2> 


./Examples/Monocular/mono_kitti Vocabulary/ORBvoc.txt Examples/Monocular/KITTI00-02.yaml "/media/j32u4ukh/TOSHIBA EXT/SLAM/data_odometry_gray/dataset/sequences/00"
./Examples/Monocular/mono_kitti Vocabulary/ORBvoc.txt Examples/Monocular/KITTI00-02.yaml "/media/j32u4ukh/TOSHIBA EXT/SLAM/data_odometry_gray/dataset/sequences/01"
./Examples/Monocular/mono_kitti Vocabulary/ORBvoc.txt Examples/Monocular/KITTI00-02.yaml "/media/j32u4ukh/TOSHIBA EXT/SLAM/data_odometry_gray/dataset/sequences/02"

./Examples/Monocular/mono_kitti Vocabulary/ORBvoc.txt Examples/Monocular/KITTI03.yaml "/media/j32u4ukh/TOSHIBA EXT/SLAM/data_odometry_gray/dataset/sequences/03"

./Examples/Monocular/mono_kitti Vocabulary/ORBvoc.txt Examples/Monocular/KITTI04-12.yaml "/media/j32u4ukh/TOSHIBA EXT/SLAM/data_odometry_gray/dataset/sequences/04"
.
.
.
./Examples/Monocular/mono_kitti Vocabulary/ORBvoc.txt Examples/Monocular/KITTI04-12.yaml "/media/j32u4ukh/TOSHIBA EXT/SLAM/data_odometry_gray/dataset/sequences/12"


$ /home/j32u4ukh/Documents/ORB_SLAM2/build> 

../Examples/Monocular/mono_kitti ../Vocabulary/ORBvoc.txt ../Examples/Monocular/KITTI00-02.yaml "/media/j32u4ukh/TOSHIBA EXT/SLAM/data_odometry_gray/dataset/sequences/00"

# 執行時間
[foreach 改版前]
詞袋數據讀取 00:09.80
median tracking time: 0.0596703
mean tracking time: 0.0700843
建圖 10:53.73

[foreach 改版後]
median tracking time: 0.0712685
mean tracking time: 0.0836848
建圖 10:16.31

[函式封裝]
New Map created with 508 points
median tracking time: 0.0859725
mean tracking time: 0.0943997
#KeyFrame: 642
#MapPoint: 76626

Vocabulary loaded! Cost 10.8229 s.
#KeyFrame: 788
#MapPoint: 100013
Total time: 6:12.6663
Median tracking time: 0.0735099
Mean tracking time: 0.082067



virtual int g2o::SparseOptimizer::optimize(int, bool): 0 vertices to optimize, maybe forgot to call initializeOptimization()
沒有頂點的可能原因：
* 都被標注為 isBad 導致沒有被加入
* 數據沒有被確實加到陣列中



DBoW2::FeatureVector kf_feature_vector = vFeatVecKF;
DBoW2::FeatureVector f_feature_vector = F.mFeatVec;

if(kf_feature_vector.first < )

for (auto feature_vector : boost::combine(kf_feature_vector, f_feature_vector)) {

    // FeatureVector == std::map<NodeId, std::vector<unsigned int> >
    pair<DBoW2::NodeId, std::vector<unsigned int>> kf_feature;
    pair<DBoW2::NodeId, std::vector<unsigned int>> f_feature;

    boost::tie(kf_feature, f_feature) = feature_vector;
    DBoW2::NodeId kf_node_id = kf_feature.first;
    DBoW2::NodeId f_node_id = f_feature.first;

    // kf_feature 起始節點較 f_feature 小
    if(kf_node_id < f_node_id){

        // 將 kf_feature 起始節點設為第 f_node_id 個節點
        kf_feature = vFeatVecKF.lower_bound(f_node_id);
    }
    
    // kf_feature 起始節點較 f_feature 大
    else if(kf_node_id > f_node_id){

        // 將 f_feature 起始節點設為第 kf_node_id 個節點
        f_feature = F.mFeatVec.lower_bound(kf_node_id);
    }   
}

[Optimizer]
g2o::SparseOptimizer optimizer;
g2o::BlockSolver_6_3::LinearSolverType *linearSolver = new g2o::LinearSolverEigen<g2o::BlockSolver_6_3::PoseMatrixType>();
g2o::BlockSolver_6_3 *solver_ptr = new g2o::BlockSolver_6_3(linearSolver);
g2o::OptimizationAlgorithmLevenberg *solver = new g2o::OptimizationAlgorithmLevenberg(solver_ptr);
optimizer.setAlgorithm(solver);


g2o::SparseOptimizer optimizer;
optimizer.setVerbose(false);
g2o::BlockSolver_7_3::LinearSolverType *linearSolver = new g2o::LinearSolverEigen<g2o::BlockSolver_7_3::PoseMatrixType>();
g2o::BlockSolver_7_3 *solver_ptr = new g2o::BlockSolver_7_3(linearSolver);
g2o::OptimizationAlgorithmLevenberg *solver = new g2o::OptimizationAlgorithmLevenberg(solver_ptr);
solver->setUserLambdaInit(1e-16);
optimizer.setAlgorithm(solver);


g2o::SparseOptimizer optimizer;
g2o::BlockSolverX::LinearSolverType *linearSolver = new g2o::LinearSolverDense<g2o::BlockSolverX::PoseMatrixType>();
g2o::BlockSolverX *solver_ptr = new g2o::BlockSolverX(linearSolver);
g2o::OptimizationAlgorithmLevenberg *solver = new g2o::OptimizationAlgorithmLevenberg(solver_ptr);
optimizer.setAlgorithm(solver);


[Vertex]
g2o::EdgeSim3ProjectXYZ *e12 = new g2o::EdgeSim3ProjectXYZ();
e12->setVertex(0, dynamic_cast<g2o::OptimizableGraph::Vertex *>(optimizer.vertex(id2)));
e12->setVertex(1, dynamic_cast<g2o::OptimizableGraph::Vertex *>(optimizer.vertex(0)));
e12->setMeasurement(obs1);



[檢查方向]

if (mbCheckOrientation)
{
    int ind1 = -1;
    int ind2 = -1;
    int ind3 = -1;

    // 篩選前三多直方格的索引值
    ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);

    for (int i = 0; i < HISTO_LENGTH; i++)
    {
        if (i == ind1 || i == ind2 || i == ind3)
            continue;
        for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
        {
            vMatches12[rotHist[i][j]] = -1;
            nmatches--;
        }
    }
}

if (mbCheckOrientation)
{
    int ind1 = -1;
    int ind2 = -1;
    int ind3 = -1;

    // 篩選前三多直方格的索引值
    ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);

    for (int i = 0; i < HISTO_LENGTH; i++)
    {
        if (i == ind1 || i == ind2 || i == ind3){
            continue;
        }

        for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
        {
            vpMatches12[rotHist[i][j]] = static_cast<MapPoint *>(NULL);
            nmatches--;
        }
    }
}

if (mbCheckOrientation)
{
    int ind1 = -1;
    int ind2 = -1;
    int ind3 = -1;

    // ind1, ind2, ind3：前三多角度的直方格的索引值
    // 篩選前三多直方格的索引值
    ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);

    for (int i = 0; i < HISTO_LENGTH; i++)
    {
        if (i != ind1 && i != ind2 && i != ind3)
        {
            for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
            {
                CurrentFrame.mvpMapPoints[rotHist[i][j]] = static_cast<MapPoint *>(NULL);
                nmatches--;
            }
        }
    }
}

if (mbCheckOrientation)
{
    int ind1 = -1;
    int ind2 = -1;
    int ind3 = -1;

    // ind1, ind2, ind3：前三多角度的直方格的索引值
    // 篩選前三多直方格的索引值
    ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);

    for (int i = 0; i < HISTO_LENGTH; i++)
    {
        if (i != ind1 && i != ind2 && i != ind3)
        {
            for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
            {
                CurrentFrame.mvpMapPoints[rotHist[i][j]] = NULL;
                nmatches--;
            }
        }
    }
}

if (mbCheckOrientation)
{
    int ind1 = -1;
    int ind2 = -1;
    int ind3 = -1;

    // ind1, ind2, ind3：前三多角度的直方格的索引值
    // 篩選前三多直方格的索引值
    ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);

    for (int i = 0; i < HISTO_LENGTH; i++)
    {
        if (i == ind1 || i == ind2 || i == ind3){
            continue;
        }
        
        // 不屬於『前三多角度的直方格的索引值』，表示第 i 個直方格的角度和大部分的不同
        // F1 運動到 F2，關鍵點的變化情形（如角度）應該相似，若角度不同，很可能是誤匹配
        for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
        {
            int idx1 = rotHist[i][j];

            // 若有匹配到
            if (vnMatches12[idx1] >= 0)
            {
                // 取消匹配認定
                vnMatches12[idx1] = -1;
                nmatches--;
            }
        }
    }
}

if (mbCheckOrientation)
{
    int ind1 = -1;
    int ind2 = -1;
    int ind3 = -1;

    // 篩選前三多直方格的索引值
    ComputeThreeMaxima(rotHist, HISTO_LENGTH, ind1, ind2, ind3);

    for (int i = 0; i < HISTO_LENGTH; i++)
    {
        if (i == ind1 || i == ind2 || i == ind3){
            continue;
        }

        for (size_t j = 0, jend = rotHist[i].size(); j < jend; j++)
        {
            vpMapPointMatches[rotHist[i][j]] = static_cast<MapPoint *>(NULL);
            nmatches--;
        }
    }
}

